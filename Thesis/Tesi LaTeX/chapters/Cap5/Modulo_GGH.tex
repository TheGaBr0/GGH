\section{Modulo GGH}
\label{sec:moduloggh}

Il modulo GGH contenente l'implementazione del relativo crittosistema è caratterizzato
da una classe \texttt{GGHCryptosystem} che al suo interno contiene tutte le funzionalità
necessarie al suo corretto andamento. Istanziando la classe è possibile passare 
diversi parametri al fine di poter modificare a piacimento determinati valori 
che verranno usati dal crittosistema in fase di cifratura e decifratura.
Tutti i parametri hanno un valore predefinito impostato a \texttt{None}, con l'eccezione del 
parametro relativo alla dimensione e dei parametri booleani. 
Se l'utente non specifica valori diversi per i parametri nulli, il modulo genererà automaticamente valori casuali per ciascuno 
di essi. I parametri consentiti sono i seguenti:
\begin{itemize}
    \item \texttt{dimension} (\texttt{fmpz\_mat}): 
    Dimensione delle basi e dei vettori generati dal crittosistema.
    \item \texttt{private\_basis} e \texttt{public\_basis} (\texttt{fmpz\_mat}, default: \texttt{None}): 
    Rispettivamente base privata e base pubblica con le quali il crittosistema effettuerà 
    tutte le operazioni.
    \item \texttt{unimodular} (\texttt{fmpz\_mat}, default: \texttt{None}):
    Matrice unimodulare usata per la generazione della base pubblica. 
    \item \texttt{message} (\texttt{fmpz\_mat}, default: \texttt{None}): 
    Vettrore rappresentante il messaggio che verrà cifrato dal crittosistema.
    \item \texttt{error} (\texttt{fmpz\_mat}, default: \texttt{None}): 
    Vettore rappresentante l'errore che verrà aggiunto in fase di cifratura.
    \item \texttt{sigma} (\texttt{Integer}, default: \texttt{None}): 
    Valore di sigma con il quale verrà generato il vettore di errore. 
    \item \texttt{integer\_sigma} (\texttt{Boolean}, default: \texttt{True}):
    Se \texttt{True}, la classe genera un sigma di tipo \texttt{Integer} anziché \texttt{Float}.
    \item \texttt{debug} (\texttt{Boolean}, default: \texttt{False}):
    Se \texttt{True}, mostra in console gli output dettagliati di tutte le fasi del 
    crittosistema, includendo il tempo richiesto per ciascuna fase. 
\end{itemize}

Dopo l'assegnazione dei valori alle variabili interne, la classe eseguirà controlli 
per verificare che, se un vettore o una base sono stati forniti come input, la loro 
dimensione sia (\texttt{dimension}, \texttt{dimension})
nel caso delle matrici e (1, \texttt{dimension}) nel caso dei vettori. Se tale condizione
dovesse risultare falsa per qualsiasi dei paramtri, come risposta la classe ritornerà
un'eccezione di tipo \texttt{ValueError}, con annesso un messaggio riguardante il parametro
che ha causato l'errore.

\subsection{Generazione delle chiavi}

La composizione delle chiavi necessita della generazione di tre elementi: 
la base privata $\mathbf{R}$, $\sigma$ e una matrice unimodulare $\mathbf{U}$. 
In \cite{GGH97} vennero proposte più opzioni di generazione
per ciascuno di questi elementi. Nella presente implementazione, sono state selezionate 
alcune opzioni specifiche tra quelle proposte, che verranno discusse singolarmente nel contesto
delle prestazioni. Le due chiavi sono rappresentate da due tuple contenute ciascuna
nel rispettivo attributo \texttt{private\_key} o \texttt{public\_key}.

\subsubsection{Chiave privata}
\label{sec:gghimplementationprivkey}
La chiave privata è rappresentata dalla sola base privata $\mathbf{R}$.
Per generarla è stato deciso di seguire i passaggi descritti 
in Sezione \ref{sec:gghkeys} al punto \ref{en:gghpriv2}. I parametri utilizzati sono
quelli descritti nei risultati sperimentali riportati in \cite{GGH97}, ovvero 
$k = (l \lceil \sqrt{\text{\texttt{dimension}}} + 1 \rceil)$ con $l = 4$. 
Attraverso un ciclo, si genera quindi prima una matrice $\mathbf{R}$ di numeri casuali 
compresi tra $[-l, l-1]$, si ottiene la base privata $\mathbf{R} = \mathbf{R}+k\mathbf{I}$ 
e si verifica che essa sia invertibile, salvando in contemporanea il risultato dell'inversione.
Se essa non dovesse risultare invertibile si procede, grazie al ciclo, ad una nuova generazione. 
L'algoritmo implementato fa uso dei moduli \texttt{Random} e \texttt{Sympy} per la rispettiva
generazione della matrice casuale e della matrice identità, le quali sono poi convertite
entrambe in \texttt{fmpz\_mat}. 

\subsubsection{Chiave pubblica}
Al contrario della chiave privata, quella pubblica è più complessa e si compone dalla tupla
$(\mathbf{B}, \sigma)$.
Dopo la generazione di $\mathbf{R}$, si procede subito con la derivazione di $\sigma$ secondo 
la prima metrica, basata sulla norma L1, introdotta in \ref{subsec:sigmametrics}. 
Per il suo calcolo 
è stato fatto uso di una conversione al tipo \texttt{decimal}. Il suo risultato, 
definito come $\rho$, viene infine usato per determinare $\sigma$ attraverso 
$\sigma = 1 / (2\rho)$. Grazie al parametro \texttt{integer\_sigma} è possibile decidere
se lasciare $\sigma$ in forma di \texttt{float} o arrotondarlo per difetto all'intero più vicino.
L'arrotondamento è necessario che sia per difetto al fine di non invalidare la precisione 
del crittosistema: la metrica basata su L1 definisce un limite a $\sigma$ sotto al quale
il successo della decifratura con base privata è sicuro. Ottenuto quindi $\sigma$ si calcola infine
la base pubblica, ottenuta dalla moltplicazione di una matrice unimodulare $\mathbf{U}$ con
la base privata $\mathbf{R}$. Per la creazione di $\mathbf{U}$ è stato scelto di usare
la tecnica descritta al punto \ref{en:gghunim1} della Sezione \ref{sec:gghkeys}, in quanto
i valori della matrice generati sono meno grandi di quelli ottenuti col metodo del punto
\ref{en:gghunim2}.
L'implementazione dell'algoritmo si basa esclusivamente su matrici \texttt{SymPy}, integrate 
con funzionalità del modulo \texttt{Random}. Questa scelta è stata fatta dopo aver condotto 
esperimenti comparativi che hanno evidenziato la superiorità di \texttt{SymPy} rispetto a FLINT 
per questo specifico caso d'uso. Analogalmente alla generazione della base privata,
il risultato finale viene poi convertito in \texttt{fmpz\_mat} .

\subsection{Cifratura e decifratura}

Il processo di cifratura e decifratura rappresenta la parte più delicata dell'implementazione di GGH.
Le operazioni al loro interno trasformano il messaggio originale in testo cifrato e viceversa, 
utilizzando le chiavi generate precedentemente. L'implementazione di questi processi 
richiede particolare attenzione per garantire sia l'efficienza computazionale che la 
sicurezza del sistema, un errore di calcolo dovuto a bassa precisione renderebbe vana 
la decifratura.

\subsubsection{Cifratura}

L'implementazione della cifratura nient'altro è che la computazione dell'equazione 
\ref{eq:GGHencryption}, la quale, fa uso di sole matrici di tipo \texttt{fmpz\_mat}.
La funzione di cifratura si occupa però prima della generazione del messaggio $\mathbf{m}$ 
e dell'errore $\mathbf{e}$, secondo i semplici passaggi descritti nella sezione 
\ref{sec:gghintroduction}. 
Per creare $\mathbf{m}$, si genera un vettore di valori casuali nell'intervallo 
$[-127, 128]$ utilizzando il modulo \texttt{Random}, che viene poi convertito in 
una matrice di razionali \texttt{fmpq\_mat}. 
A causa di incompatibilità operative tra oggetti \texttt{fmpz\_mat} e \texttt{fmpq\_mat}, è
obbligatorio salvare $\mathbf{m}$ come oggetto di tipo razionale. Questa conversione 
è necessaria perché durante la fase di cifratura si verifica un'operazione di somma 
tra un \texttt{fmpq\_mat} e un \texttt{fmpz\_mat}. Se $\mathbf{m}$ non viene convertito 
in formato razionale, l'operazione causa inevitabilmente un errore di tipo 
\texttt{TypeError} nell'ambiente FLINT. Questa conversione forzata non causa nessun effetto
negativo in quanto, in seguito a esperimenti, sia velocità che precisione non sono intaccati.  
Per $\mathbf{e}$, si generano valori 
casuali nell'intervallo $\pm \sigma$. La conversione finale di $\mathbf{e}$ dipende 
dal parametro \texttt{integer\_sigma}: se vero, risulta in una matrice \texttt{fmpz\_mat} 
di interi; se falso, produce una matrice \texttt{fmpq\_mat} di razionali. 

\subsubsection{Decifratura}

La decifratura nel crittosistema GGH si basa essenzialmente sulla risoluzione del CVP. 
In \cite{GGH97}, gli autori presentano due approcci principali: il metodo del piano più 
vicino e la tecnica di arrotondamento di Babai. Un'analisi dei vantaggi e 
degli svantaggi di entrambi gli algoritmi è stata trattata nella Sezione \ref{sec:babai}. 
La scelta implementativa è ricaduta sulla tecnica di arrotondamento, principalmente per la sua 
efficienza computazionale, rinunciando però alla precisione massima ottenibile. Questa perdita
di precisione non influisce però sulle probabilità di decifratura, come mostrato in tabella
X sezione X. 
L'implementazione della decifratura segue fedelmente i passaggi illustrati nell'esempio 
\ref{exp:GGH}, mentre l'algoritmo di Babai applicato è stato dettagliatamente descritto 
nell'esempio \ref{exp:babai}. Tutti i calcoli sono gestiti completamente da FLINT eccetto
per la funzione di arrotondamento all'intero più vicino, nativa di Python. La funzione di 
decifratura ritorna infine il messaggio decifrato sottoforma di \texttt{fmpq\_mat}. 

\subsection{Caso d'uso}

Un esempio d'utilizzo generico è proposto in Figura \ref{fig:gghmoduleexample}: una volta 
importata la classe \texttt{GGHCryptosystem} è possibile istanziarla. In questo caso, 
l'istanza viene creata senza parametri aggiuntivi, ad eccezione della dimensione obbligatoria.
Dato che tutti i parametri sono nulli, la classe genererà casualmente sia le basi che i 
vettori. Subito dopo l'istanza, verranno create le chiavi pubblica e privata. Gli altri 
attributi, come il messaggio, l'errore e il testo cifrato, verranno generati al momento 
della chiamata della funzione \texttt{encrypt}. Utilizzando la funzione \texttt{decrypt} invece, 
si potrà ottenere il testo decifrato e verificarne la correttezza con un semplice controllo.

\begin{figure}[H]
    \begin{python}
        from GGH_crypto import GGHCryptosystem
        dimension = 100

        GGH_object = GGHCryptosystem(dimension = dimension)
        GGH_object.encrypt()

        message = GGH_object.message
        decrypted_message = GGH_object.decrypt()

        print(decrypted_message == message)
    \end{python}
    \caption{Esempio di funzionamento della classe \texttt{GGHCryptosystem}.}
    \label{fig:gghmoduleexample}
\end{figure}

