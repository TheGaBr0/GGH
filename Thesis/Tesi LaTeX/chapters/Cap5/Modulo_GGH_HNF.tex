\section{Modulo GGH-HNF}
\label{sec:moduloggh-hnf}

Poiché GGH-HNF è una variante di GGH, la sua implementazione mantiene la stessa struttura 
e utilizza alcuni dei parametri e dei meccanismi precedentemente descritti nella scorsa sezione.
Il modulo è anch'esso costituito da una classe principale, \texttt{GGHHNFCryptosystem}, che, come nel 
caso del modulo fratello GGH, serve da contenitore per l'accesso a tutte le funzioni.
I parametri ereditati e mantenuti da GGH sono: \texttt{dimension}, \texttt{private\_basis},
\texttt{public\_basis}, \texttt{error} e \texttt{debug}, che mantengono le stesse proprietà
e sono soggetti agli stessi controlli. I nuovi parametri invece sono i seguenti:
\begin{itemize}
    \item \texttt{lattice\_point} (\texttt{fmpz\_mat}, default: \texttt{None}) : 
    Vettore rappresentante un punto del reticolo, il quale, una volta moltiplicato con la
    base pubblica, verrà sottratto ad \texttt{error} in fase di cifratura.
    \item \texttt{alpha} (\texttt{Float}, default: 0.75):
    Valore decimale usato come fattore moltiplicativo per $\rho$ in fase di 
    generazione dell'errore causale. La sua lughezza sarà garantita essere
    strettamente minore di  $\alpha\rho$.
    \item \texttt{GGH\_private} (\texttt{Boolean}, default: \texttt{False}):
    Se \texttt{True}, utilizza la tecnica di generazione della base privata di GGH invece di 
    quella proposta da Micciancio. 
\end{itemize}

\subsection{Generazione delle chiavi}

Diversamente da GGH, lo schema GGH-HNF richiede la generazione di solo due elementi 
per le chiavi: la base privata e $\rho$. In \cite{HNF01}, Micciancio propone un metodo 
alternativo per la generazione della base privata, pur riconoscendo che l'approccio 
utilizzato in GGH e descritto nell'implementazione della Sezione \ref{sec:gghimplementationprivkey} 
fosse già adeguatamente efficiente. Dato che ambedue le tecniche generano basi con 
proprietà diverse, è stato scelto di adottarle entrambe dando scelta all'utente di decidere
quale usare attraverso il parametro \texttt{GGH\_private}. Di default la scelta ricade
sulla tecnica proposta da Micciancio. 

\subsubsection{Chiave privata}

Come per GGH, la chiave privata è rappresentata dalla sola base privata $\mathbf{R}$.
La funzione che si occupa della sua generazione si articola in due fasi indipendenti, 
determinate dal parametro \texttt{GGH\_private}. Se \texttt{GGH\_private}
è settato a \texttt{True}, viene utilizzato l'algoritmo impiegato nell'implementazione di GGH.
In caso contrario, il programma avvia un ciclo in cui genera matrici di numeri casuali 
nell'intervallo $[-\texttt{dimension},\texttt{dimension}]$, le riduce tramite l'algoritmo 
LLL e poi le inverte. Se l'inversione fallisce, il ciclo riparte fino a ottenere una 
matrice LLL-ridotta invertibile. 
Come per il primo metodo, anche il secondo sfrutta il modulo \texttt{Random} per la 
generazione della matrice.

\subsubsection{Chiave pubblica}

Anche la chiave pubblica, come quella privata, presenta delle somiglianze con la sua 
controparte nel caso di GGH, con la sola eccezione del parametro $\sigma$. 
In GGH-HNF, infatti, $\sigma$ non è presente ed è sostituito da $\rho$. 
Pertanto, la chiave pubblica è costituita dalla tupla $(\mathbf{B}, \rho)$. Come spiegato
in \ref{sec:ggh-hnf}, la base pubblica è ottenibile con il semplice calcolo della forma
normale di Hermite, operazione direttamente integrata in FLINT. Al contrario invece il 
calcolo del $\rho$ è più oneroso, poiché richiede l'ortogonalizzazione tramite il 
metodo di Gram-Schmidt, descritto in Algoritmo \ref{alg:one}. Questo algoritmo è stato 
implementato nel modulo \texttt{Utils} con l'ausilio di \texttt{Numpy}, una sua discussione più 
approfondita può essere trovata nella sottosezione dedicata in Sezione \ref{sec:moduloutils}. 
Dopo aver ortogonalizzato la base privata, non resta che trovare la norma minima euclidea 
ed effettuare il calcolo come definito in Equazione \ref{eq:rho}. 
Per determinare la norma, è stata utilizzata uitilizzata la funzione illustrata in Figura 
\ref{fig:conversione}, che sfrutta il modulo \texttt{Decimal}.

\subsection{Cifratura e decifratura}

I processi di cifratura e decifratura di GGH-HNF mantengono la stessa struttura generale 
di quelli presenti nell'implementazione di GGH, con alcune differenze fondamentali. 
La decifratura segue 
fedelmente l'algoritmo già presente in GGH, mantenendo gli stessi vantaggi e svantaggi
nella risoluzione del CVP. Al contrario, la cifratura subisce una modifica significativa, 
poiché utilizza un approccio diverso per la generazione e gestione del messaggio e 
dell'errore.

\subsubsection{Cifratura}

Come precedentemente introdotto, la cifratura differisce completamente adottando 
l'Equazione \ref{eq:HNFencryption}. Data $\mathbf{B}$, due sono gli elementi mancanti: un punto $\mathbf{x}$ 
del reticolo e l'errore $\mathbf{e}$. Il primo valore viene calcolato direttamente usando
l'Equazione \ref{eq:HNFreduction}  che sfrutta interamente le matrici FLINT e l'operazione 
arrotondamento per difetto nativa di Python. 
La generazione dell'errore utilizza una funzione che crea un vettore di errore casuale
attraverso il modulo \texttt{Random}. Il vettore di errore viene generato attraverso un processo 
iterativo che inizia con la creazione di un vettore casuale nell'intervallo 
[-\texttt{dimension}, \texttt{dimension}]. Viene calcolata poi la lunghezza del vettore che 
deve essere strettamente inferiore a $\texttt{alpha}\times\rho$. Se così non fosse, il vettore 
viene rigenerato con valori casuali diminuendo il parametro \texttt{dimension} dal range 
iniziale finché non si ottiene un errore che soddisfa il criterio desiderato. 
Questo metodo assicura che l'errore generato sia sempre entro i limiti accettabili definiti
dal $\rho$, dando la possibilità all'utente di poter controllare la probabilità di decifratura
con base privata attraverso il parametro \texttt{alpha}.
\subsubsection{Decifratura}

La decifratura, come introdotto, segue gli stessi passaggi di GGH, con l'unica differenza 
nel valore di ritorno. Dato che il messaggio da recuperare è codificato in $\mathbf{e}$ è
necessario ritornare il testo cifrato a cui viene sottratto il risultato della tecnica
di arrotondamento di Babai, come mostrato più dettagliatamente nell'Esempio \ref{exp:HNF}. 
La scelta di questo algoritmo per la risoluzione del CVP porta a un'ulteriore conseguenza:
la lunghezza del vettore di errore $\mathbf{e}$ non basta che sia semplicemente minore di $\rho$, 
ma è necessario che sia significativamente più piccola a causa della inferiore precisione dell'algoritmo. 
Risultati sperimentali, osservabili in Tabella \ref{tab:combined_successes_hnf} Sezione 
\ref{sec:risultati_cifratura_decifratura}, hanno dimostrato che è sufficiente un 
$\mathbf{e} < 0.8\rho$ per assicurare un successo con probabilità stimata del 97.92\%. 
Inoltre, nel caso in cui il parametro \texttt{GGH\_private} sia impostato su \texttt{True}, 
gli stessi risultati indicano che un valore di $\mathbf{e} < \rho$ garantisce una probabilità di 
decifratura pari al 100\%.
\subsection{Caso d'uso}

Come osservabile in Figura \ref{fig:gghhnfmoduleexample}, il caso d'uso della classe 
\texttt{GGHHNFCryptosystem} risulta quasi identico a quello del
modulo \texttt{GGH} in quanto, come già discusso, entrambi i sistemi seguono la stessa struttura.  
L'unica differenza sostanziale sta nel fatto che l'attributo \texttt{message} non è più 
presente e al suo posto viene utilizzato \texttt{error}. 

\begin{figure}[h]
    \begin{python}
        from GGH_crypto import GGHHNFCryptosystem
        dimension = 100

        GGHHNF_object = GGHHNFCryptosystem(dimension = dimension)
        GGHHNF_object.encrypt()

        message = GGHHNF_object.error
        decrypted_message = GGHHNF_object.decrypt()

        print(f"message: {message}")
    \end{python}
    \caption{Esempio di funzionamento della classe \texttt{GGHHNFCryptosystem}.}
    \label{fig:gghhnfmoduleexample}
\end{figure}