\section{Modulo GGH-HNF}
\label{sec:moduloggh-hnf}

Poiché GGH-HNF è una variante di GGH, la sua implementazione mantiene la stessa struttura 
e utilizza alcuni dei parametri e dei meccanismi precedentemente descritti nella scorsa sezione.
Il modulo è anch'esso costituito da una classe principale, \texttt{GGHHNFCryptosystem}, che, come nel 
caso del modulo fratello GGH, serve da contenitore per l'accesso a tutte le funzioni.
I parametri ereditati e mantenuti da GGH sono: \texttt{dimension}, \texttt{private\_basis},
\texttt{public\_basis}, \texttt{error} e \texttt{debug}, che mantengono le stesse proprietà
e sono soggetti agli stessi controlli. I nuovi parametri invece sono i seguenti:
\begin{itemize}
    \item \texttt{lattice\_point} (\texttt{fmpz\_mat}, default: \texttt{None}) : 
    Vettore rappresentante un punto del reticolo, il quale, una volta moltiplicato con la
    base pubblica, verrà sottratto ad \texttt{error} in fase di cifratura.
    \item \texttt{GGH\_private} (\texttt{Boolean}, default: \texttt{False}):
    Se \texttt{True}, utilizza la tecnica di generazione della base privata di GGH invece di 
    quella proposta da Micciancio. 
\end{itemize}

\subsection{Generazione delle chiavi}

Diversamente da GGH, lo schema GGH-HNF richiede la generazione di solo due elementi 
per le chiavi: la base privata e $\rho$. In \cite{HNF01}, Micciancio propone un metodo 
alternativo per la generazione della base privata, pur riconoscendo che l'approccio 
utilizzato in GGH e descritto nell'implementazione della Sezione \ref{sec:gghimplementationprivkey} 
fosse già adeguatamente efficiente. Dato che ambedue le tecniche generano basi con 
proprietà diverse, è stato scelto di adottarle entrambe dando scelta all'utente di decidere
quale usare attraverso il parametro \texttt{GGH\_private}. Di default la scelta ricade
sulla tecnica proposta da Micciancio. 

\subsubsection{Chiave privata}

Come per GGH, la chiave privata è rappresentata dalla sola base privata $\mathbf{R}$.
La funzione che si occupa della sua generazione si articola in due fasi indipendenti, 
determinate dal parametro \texttt{GGH\_private}. Se \texttt{GGH\_private}
è settato a \texttt{True}, viene utilizzato l'algoritmo impiegato nell'implementazione di GGH.
In caso contrario, il programma avvia un ciclo in cui genera matrici di numeri casuali 
nell'intervallo $[-\texttt{dimension},\texttt{dimension}]$, le riduce tramite l'algoritmo 
LLL e poi le inverte. Se l'inversione fallisce, il ciclo riparte fino a ottenere una 
matrice LLL-ridotta invertibile. 
Come per il primo metodo, anche il secondo sfrutta il modulo \texttt{Random} per la 
generazione della matrice.

\subsubsection{Chiave pubblica}

Anche la chiave pubblica, come quella privata, presenta delle somiglianze con la sua 
controparte nel caso di GGH, con la sola eccezione del parametro $\sigma$. 
In GGH-HNF, infatti, $\sigma$ non è presente ed è sostituito da $\rho$. 
Pertanto, la chiave pubblica è costituita dalla tupla $(\mathbf{B}, \rho)$. Come spiegato
in \ref{sec:ggh-hnf}, la base pubblica è ottenibile con il semplice calcolo della forma
normale di Hermite, operazione direttamente integrata in FLINT. Al contrario invece il 
calcolo del $\rho$ è molto più oneroso, poiché richiede l'ortogonalizzazione tramite il 
metodo di Gram-Schmidt, descritto in Algoritmo \ref{alg:one}. Tale implementazione è 
presente solo nel modulo Sympy ma, data la particolare forma dei parametri richiesta in input, 
si è preferito procedere con la riscrittura dell'algoritmo integrata nel modulo \texttt{Utils}.
Dopo aver ortogonalizzato la base privata, non resta che trovare la norma minima euclidea 
ed effettuare il calcolo come definito in Equazione \ref{eq:rho}. 
Per determinare la norma, è stato utilizzato l'algoritmo illustrato in Figura 
\ref{fig:conversione}, che sfrutta il modulo \texttt{Decimal}.

\subsection{Cifratura e decifratura}

I processi di cifratura e decifratura di GGH-HNF mantengono la stessa struttura generale 
di quelli presenti nell'implementazione di GGH, con alcune differenze fondamentali. 
La decifratura segue 
fedelmente l'algoritmo già presente in GGH, mantenendo gli stessi vantaggi e svantaggi
nella risoluzione del CVP. Al contrario, la cifratura subisce una modifica significativa, 
poiché utilizza un approccio diverso per la generazione e gestione del messaggio e 
dell'errore.

\subsubsection{Cifratura}

Come precedentemente introdotto, la cifratura differisce completamente adottando 
l'Equazione \ref{eq:HNFencryption}. Data $\mathbf{B}$, due sono gli elementi mancanti: un punto $\mathbf{x}$ 
del reticolo e l'errore $\mathbf{e}$. Il primo valore viene calcolato direttamente usando
l'Equazione \ref{eq:HNFreduction}  che sfrutta interamente le matrici FLINT e l'operazione 
arrotondamento per difetto nativa di Python. 
La generazione dell'errore utilizza una funzione che crea un vettore di errore casuale
attraverso il modulo \texttt{Random}. Il vettore di errore viene generato attraverso un processo 
iterativo che inizia con la creazione di un vettore casuale nell'intervallo 
[-\texttt{dimension}, \texttt{dimension}]. Viene calcolata poi la lunghezza del vettore che 
deve essere inferiore a $\alpha\rho$ con $\alpha$ che rappresenta un coefficiente moltiplicativo 
compreso tra 0 e 1. Se così non fosse, il vettore viene rigenerato con valori casuali 
più piccoli, finché non si ottiene un errore che soddisfa il criterio desiderato. 
Questo metodo assicura che l'errore generato sia sempre entro i limiti accettabili definiti
dal $\rho$ e che quindi la decifratura con base privata abbia una probabilità di successo
legata al parametro $\alpha$.
\subsubsection{Decifratura}

La decifratura, come introdotto, segue gli stessi passaggi di GGH, con l'unica differenza 
nel valore di ritorno. Dato che il messaggio da recuperare è codificato in $\mathbf{e}$ è
necessario ritornare il testo cifrato a cui viene sottratto il risultato della tecnica
di arrotondamento di Babai, come mostrato più dettagliatamente nell'Esempio \ref{exp:HNF}. 
La scelta di questo algoritmo per la risoluzione del CVP porta a un'ulteriore conseguenza:
il vettore di errore $\mathbf{e}$ non basta che sia semplicemente minore di $\rho$, 
ma è necessario che sia metodicamente minore a causa della minore precisione dell'algoritmo. 
Esperimenti hanno dimostrato che è sufficiente un $\mathbf{e} < 0.9\rho$. 

\subsection{Caso d'uso}

Come osservabile in Figura \ref{fig:gghhnfmoduleexample}, il caso d'uso della classe 
\texttt{GGHHNFCryptosystem} risulta quasi identico a quello del
modulo \texttt{GGH} in quanto, come già discusso, entrambi i sistemi seguono la stessa struttura.  
L'unica differenza sostanziale sta nel fatto che l'attributo \texttt{message} non è più 
presente e al suo posto viene utilizzato \texttt{error}. 

\begin{figure}[h]
    \begin{python}
        from GGH_crypto import GGHHNFCryptosystem
        dimension = 100

        GGHHNF_object = GGHHNFCryptosystem(dimension = dimension)
        GGHHNF_object.encrypt()

        message = GGHHNF_object.error
        decrypted_message = GGHHNF_object.decrypt()

        print(f"message: {message}")
    \end{python}
    \caption{Esempio di funzionamento della classe \texttt{GGHHNFCryptosystem}.}
    \label{fig:gghhnfmoduleexample}
\end{figure}