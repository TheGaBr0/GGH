\section{Tecnologie adottate e motivazioni}
\label{sec:motivations}
La prima scelta che deve essere presa prima di iniziare a strutturare
le implementazioni è il linguaggio di programmazione.
Questo gioca un ruolo fondamentale sia per quanto riguarda l'efficienza del codice e sia 
per quanto riguarda la sua usabilità sui diversi sistemi operativi. Spesso, quando si tratta 
di operazioni matematiche complesse, la scelta di linguaggi di programmazione ad alte 
prestazioni è fondamentale. I reticoli, ed in particolare i problemi legati ad essi, richiedono
calcoli precisi e veloci, talvolta con numeri molto grandi o molto piccoli.
Questo compito viene spesso affidato al linguaggio di programmazione C, alle sue varianti
come C++ o a linguaggi specializzati in calcoli matematici come Mathematica. 

Alcuni esempi di librerie C specifiche utilizzate possono essere osservati direttamente 
negli studi svolti dagli autori citati nei precedenti capitoli:
\begin{itemize}
    \item \cite{HNF01,HNF04,Nguyen400}, dove viene utilizzata la Number Theory Library (NTL).
    \item \cite{GGH97, Nguyen99}, in cui è stata impiegata la libreria LiDiA.
\end{itemize}

La scelta di C risulta quindi essere molto popolare e giustificata dalla sua efficienza. 
E' però necessario precisare che, dati gli anni di pubblicazione degli studi originali, molti
dei linguaggi di programmazione attualmente in circolazione non potevano essere presi 
in considerazione, poichè semplicemente non esistenti o non sufficientemente maturi. 
Alcuni dei più recenti linguaggi
popolari al giorno d'oggi riescono non solo a pareggiare o superare la velocità di C, ma
risolvono anche altri suoi problemi intrinsechi, come il non essere multipiattaforma
e non avere sistemi di sicurezza per quanto riguarda la memoria. \\
Alcuni esempi includono Rust, nato nel 2015, e Python, introdotto nel 1991, molto prima 
che venisse pubblicato GGH e le sue varianti. Nello specifico, quest'ultimo, ha attraversato 
un'evoluzione significativa nel corso degli anni, diventando oggi il linguaggio 
di programmazione più richiesto e utilizzato dalle aziende.
In particolare Python gode delle seguenti proprietà:

\begin{itemize}
    \item Leggibilità e semplicità del codice: Python utilizza una sintassi 
    chiara e concisa che rende il codice facile da leggere e mantenere riducendo 
    il rischio di errori.
    \item Compatibilità multipiattaforma: Python è un linguaggio interpretato e 
    multipiattaforma, il che significa che il codice può essere eseguito su diversi 
    sistemi operativi (Windows, macOS, Linux) senza richiedere modifiche sostanziali.
    \item Gestione automatica della memoria: Python gestisce automaticamente la memoria 
    attraverso un garbage collector, riducendo il rischio di memory leaks e semplificando 
    lo sviluppo rispetto a linguaggi come C, dove la gestione manuale della memoria è richiesta.
    \item Sicurezza: Python offre protezioni intrinseche contro problemi di sicurezza 
    comuni, come buffer overflow, che sono invece frequenti in linguaggi a basso livello come C.
    \item Estendibilità: Python può essere facilmente esteso con moduli 
    scritti in C, C++ o Cython per migliorare le prestazioni e l'efficienza. 
    \item Gestione di numeri con precisione illimitata: Python è dotato di funzionalità 
    native per manipolare interi di qualsiasi grandezza senza restrizioni. Inoltre, 
    tramite il modulo \texttt{Decimal}, offre la possibilità di operare con numeri 
    decimali a precisione arbitraria. 
\end{itemize}

Alla luce di queste caratteristiche, Python si rivela un'opzione ottimale per lo sviluppo 
dei progetti richiesti. Sebbene sia generalmente noto come meno veloce rispetto a 
linguaggi come C, questa potenziale limitazione può essere efficacemente compensata. 
La capacità di Python di integrarsi con moduli scritti in linguaggi più efficienti dal 
punto di vista delle prestazioni offre un modo pratico per migliorare la velocità di 
esecuzione dove necessario, combinando così la facilità d'uso di Python con l'efficienza 
di linguaggi di più basso livello.
Sfruttando la menzionata estendibilità di Python, si è affrontata la sfida delle prestazioni 
in operazioni matriciali complesse, come l'inversione, che risultano particolarmente onerose 
per dimensioni elevate (come evidenziato dai dati nella Sezione \ref{sec:HNFLimits}). 
In Python, la scelta più ovvia quando si deve operare con grandi numeri e con alta velocità,
ricade spesso sulla libreria Numpy. 
Questa preferenza è dovuta principalmente alle prestazioni superiori di Numpy nell'elaborazione 
di array multidimensionali e alla sua vasta gamma di funzioni matematiche ottimizzate, 
che la rendono particolarmente efficiente per calcoli scientifici e numerici su larga scala. 
Tuttavia, Numpy utilizza tipi di dati a precisione fissa, con un massimo di 64 bit per i 
sistemi operativi più comuni, che 
possono risultare insufficienti per calcoli che richiedono una precisione estremamente 
elevata o che coinvolgono numeri al di fuori del range rappresentabile con 64 bit. 
Questa limitazione può portare a errori di arrotondamento o overflow in operazioni 
matematiche complesse o con numeri estremamente grandi, resta comunque possibile e utile
l'uso di questo modulo, ma con molta attenzione al tipo di calcoli affidatogli.
Per ottimizzare queste operazioni mantenendo al contempo il vantaggio della precisione 
arbitraria di Python, si è scelto di integrare una libreria specializzata scritta in un 
linguaggio ad alte prestazioni. La Fast Library for Number Theory \cite{FLINT} (FLINT) è stata 
selezionata per questo scopo critico, offrendo un equilibrio ideale tra velocità e 
precisione.
La possibilità di integrare FLINT tramite PyPI e richiamare direttamente le sue funzioni 
da Python, consente di incorporare facilmente la libreria nel progetto, combinando così 
l'efficienza computazionale con la flessibilità e la leggibilità del codice Python. 
Tuttavia, a causa delle limitate funzionalità offerte dall'integrazione di FLINT e per 
semplificare il codice, è stato necessario utilizzare altre librerie esterne di supporto.
I principali moduli e librerie utilizzati nel progetto, oltre a FLINT, sono:

\begin{itemize}
    \item \texttt{Numpy}: Modulo esterno che, come già introdotto, si specializza in calcoli
    numerici e matematici con particolare attenzione all'efficienza. Il suo utilizzo può
    diventare rischioso a causa della sua limitata precisione a "soli" 64 bit, per questo 
    il suo utilizzo è confinato in contesti testati e dalla relativa importanza  numerica, 
    dove la precisione limitata non compromette l'accuratezza dei risultati finali.
    \item \texttt{Sympy}: Modulo esterno dedicato ai calcoli simbolici a precisione arbitraria.
    Utilizzato come supporto a FLINT grazie alle sue numerose funzioni già pronte e il 
    mantenimento della precisione nei calcoli. A causa delle sue basse performance, il suo
    utilizzo è strettamente limitato a funzioni di bassa complessità.
    \item \texttt{Decimal} e \texttt{Fraction}: Moduli nativi Python per la gestione di numeri decimali e 
    frazionari a precisione arbitraria. La loro funzione è quella di sostituire FLINT ove 
    esso non può fornire una soluzione diretta o dove Sympy risulta troppo lento.
    \item \texttt{Random}: Modulo Python nativo che si occupa di generazione pseudo-casuale di dati.
    Utilizzato solo ed esclusivamente per la generazione di basi e vettori randomici. 
\end{itemize}

Questi moduli non rappresentano l'interezza delle librerie utilizzate nel progetto, ma solo
le principali, utilizzate in vari punti del codice di ciascuna implementazione e che giocano
un ruolo importante nel progetto. \\
Per gli algoritmi complessi e ad alta precisione, come quelli di riduzione reticolare, 
si è optato, ove possibile, per l'utilizzo di implementazioni efficienti e testate 
provenienti da librerie esterne, anziché riscriverli in Python. 
Nello specifico:
\begin{itemize}
    \item L'algoritmo LLL è stato integrato direttamente tramite una sua versione presente in FLINT.
    \item L'algoritmo BKZ è stato incorporato mediante la libreria open-source FPLLL \cite{FPLLL}, 
    che offre implementazioni in virgola mobile di vari algoritmi di riduzione per reticoli, tra cui
    anche LLL.
    \item Per l'algoritmo di Gram-Schmidt, non avendo trovato un'implementazione rapida 
    e facilmente integrabile, si è proceduto a una riscrittura in Python attraverso l'uso 
    di \texttt{Numpy}.
\end{itemize}

E' importante precisare che FPLLL è disponibile solo per il sistema operativo Linux, impedendo
quindi di poter funzionare su più piattaforme, punto importante del progetto. Il problema 
è stato superato su Windows grazie all'introduzione del Windows Subsystem for Linux (WSL). 
Questa tecnologia consente di eseguire un ambiente Linux virtualizzato  
all'interno di Windows, integrandosi con il sistema operativo e permettendo di richiamare 
funzionalità Linux direttamente.

%
%          STRUTTURA DEL PACCHETTO
%
\subfile{Struttura.tex}
%
%          FLINT
%
\subfile{Python_tipizzazione.tex}