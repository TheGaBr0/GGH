\subsection{Integrazione e gestione di FLINT}
\label{sec:FLINT}

Come introdotto nella sezione \ref{sec:motivations}, FLINT è un modulo cardine nell'implementazione 
proposta, che si rende responsabile della gestione dei calcoli ad alta precisione ed efficienza. 
FLINT riesce nel suo intento grazie a dei tipi di dati specializzati, 
progettati appositamente per gestire numeri di precisione arbitraria. Nello specifico, 
tra i diversi tipi proposti da FLINT, due sono quelli utilizzati nel progetto:
\begin{itemize}
    \item \texttt{fmpz} (Fast Multiple Precision Integers)
    \item \texttt{fmpq} (Fast Multiple Precision Rationals)
\end{itemize}

e le loro varianti per il calcolo matriciale: \texttt{fmpz\_mat} e \texttt{fmpq\_mat}. 
Python, essendo un linguaggio a tipizzazione dinamica, non dispone nativamente di tipi 
di dati statici come quelli offerti da FLINT su C. Tuttavia, per sfruttare le potenti 
funzionalità di FLINT in Python, sono stati sviluppati dei bindings ovvero delle
interfacce che consentono l'interoperabilità tra i due linguaggi.
Grazie a questi bindings, è possibile creare oggetti FLINT direttamente in Python:
\begin{enumerate}
    \item Tipi interi:
    \begin{itemize}
        \item Gli oggetti \texttt{fmpz} possono essere istanziati a partire da valori 
        \texttt{Integer}.
    \end{itemize}
    \item Tipi razionali:
    \begin{itemize}
        \item Gli oggetti \texttt{fmpq} possono essere creati fornendo due valori 
        \texttt{Integer} rappresentanti rispettivamente numeratore e denominatore.
    \end{itemize}
    \item Matrici:
    \begin{itemize}
        \item \texttt{fmpz\_mat} (matrici di interi) possono essere generate da una 
        lista di liste 
        contenenti valori \texttt{fmpq} o \texttt{Integer}.
        \item \texttt{fmpq\_mat} (matrici di razionali) possono essere create da da una 
        lista di liste 
        contenenti valori \texttt{fmpz}, \texttt{Integer}, o \texttt{fmpq}
    \end{itemize}
\end{enumerate}
Sebbene questo sistema sia in grado di fornire alta efficienza e precisione, esso comporta
una maggiore complicazione qualora FLINT non sia in grado di fornire una soluzione integrata 
e diretta, come
nei casi della radice quadrata e della potenza. Per risolvere il problema sono
state quindi implementate delle conversioni attraverso codice statico o funzioni.
Tali conversioni utilizzano funzionalità di moduli più versatili come Sympy o Decimal, 
ma a scapito dell'efficienza. Sebbene questi moduli offrano una 
maggiore flessibilità, essi non sono ottimizzati per operazioni aritmetiche a basso livello 
come lo è FLINT. Ad esempio, Sympy è una libreria simbolica scritta in Python, e per 
questo motivo risulta più lenta, poiché oltre ai calcoli deve gestire anche 
l'interpretazione simbolica delle espressioni.

Un esempio di conversione da un oggetto \texttt{fmpq\_mat} a \texttt{Decimal} è illustrato 
in \ref{fig:conversione}. Dopo aver verificato che l'oggetto in questione sia di tipo  
\texttt{fmpq\_mat}, 
si estrae il numeratore e il denominatore, li si converte in interi e infine si effettua 
la conversione in \texttt{Decimal}. 

\begin{figure}[h]
    \begin{python}
        def vector_norm(row):
            if isinstance(row, fmpz_mat):
                row = fmpq_mat(row)

            getcontext().prec = 50
            
            return Decimal(
                sum(
                    (Decimal(int(x.numer())) / 
                    Decimal(int(x.denom()))) ** 2 
                    for x in row)
                ).sqrt()
    \end{python}
    \caption{Conversione di un oggetto \texttt{fmpq\_mat} in \texttt{Decimal}}
    \label{fig:conversione}
\end{figure}