\section{Algoritmi per la risoluzione del CVP}
\label{CVP}


\subsection{Algoritmi di Babai}
\label{sec:babai}
Nel 1986 Babai\cite{Babai86}  propose due algoritmi per la risoluzione di apprCVP, i cosiddetti:
"Metodo del Piano più Vicino" e "Tecnica di Arrotondamento". Ai fini di questa tesi, 
entrambi verranno trattati, sebbene il primo sarà discusso in modo più conciso 
poiché, come verrà spiegato nei prossimi capitoli, non è stato utilizzato nelle 
implementazioni proposte. \\
Il metodo del piano più vicino è il primo algoritmo presentato da Babai, esso si basa sull'impiegare 
l'ortogonalizzazione di Gram-Schmidt per semplificare il problema. L'algoritmo inizia quindi
ortogonalizzando la base del reticolo fornita in 
input attraverso Gram-Schmidt. Successivamente, procede in maniera iterativa a partire 
dalla dimensione più alta: il vettore input viene proiettato sul vettore base ortogonale 
corrispondente e questa proiezione viene approssimata al multiplo intero più vicino del 
vettore della base originale. Tale approssimazione viene sottratta dal vettore input, 
generando un nuovo vettore residuo. Questo processo viene ripetuto per le dimensioni 
inferiori, una alla volta, fino a coprire tutte le dimensioni. Al termine, l'algoritmo 
fornisce come risultato una soluzione all'apprCVP. 
Grazie alla sua complessità polinomiale, l'algoritmo riesce a bilanciare efficacemente 
l'accuratezza dell'approssimazione con il tempo di esecuzione. Per ulteriori dettagli e 
informazioni sull'algoritmo si veda \cite{Galbraith18}. 
\\
Il secondo algoritmo è la tecnica di arrotondamento che, come da nome, si basa
principalmente sull'arrotondare dei valori frazionari all'intero più vicino.
Seppur la sua implementazione risulti semplice e banale, in realtà la sua dimostrazione teorica
è tutt'altro che immediata. 
A differenza del precedente, 
non utilizza l'ortogonalizzazione di Gram-Schmidt, ma mantiene comunque una complessità 
polinomiale. Di seguito viene fornita una spiegazione del suo funzionamento. \\
Come discusso nella Sezione \ref{sec:dominio}, dati un reticolo $\mathcal{L}$ di dimensione
$n$ e una sua base $\mathbf{B}$, per ogni vettore $\mathbf{t} \in \mathbb{R}^n$,
con $\mathbf{t} \notin \mathcal{L}$, un'unica decomposizione $\mathbf{t} = \mathbf{f} + \mathbf{v}$
può essere sempre trovata in modo tale che $\mathbf{v} \in \mathcal{L}$ e $\mathbf{f}$ si collochi
nel dominio fondamentale $\mathcal{F}$ di $\mathbf{B}$. Questa proprietà fornisce l'idea
dietro alla risoluzione dell'apprCVP usata da questo algoritmo: identificare il dominio fondamentale (traslato) rispettivamente
a $\mathbf{v} \in \mathcal{L}$, nel quale il vettore target $\mathbf{t}$ si trova. 
Sia $\mathcal{L}$ un reticolo con 
dimensione $n$ generato da una base (buona) $\mathbf{B}$ e sia $\mathbf{t}$ un vettore tale che
$\mathbf{t} \in \mathbb{R}^n$ e $\mathbf{t} \notin \mathcal{L}$. Dato che $\mathbf{B}$ è una
matrice di rango massimo, è possibile calcolare:
\[
    \mathbf{x} = \mathbf{t}\mathbf{B}^{-1}
\]
Da qui si applica la tecnica di arrotondamento, la quale è semplicemente:
\[
    \mathbf{w} = \sum_{i=1}^{n} \lfloor \mathbf{x}_i \rceil  \mathbf{b}_i
\]
con $\mathbf{B} = [\mathbf{b}_1,\dots,\mathbf{b}_n]$ e $\lfloor\mathbf{x}\rceil$ che significa
prendere l'intero più vicino al numero reale $\mathbf{x}$. Questo algoritmo mira ad 
identificare il dominio fondamentale (traslato) che il vettore $\mathbf{t}$ localizza e la sua
correttezza è strettamente legata alla forma geometrica del dominio fondamentale, è necessaria
quindi una base di alta qualità al fine di avere risultati validi. 

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[framed, scale=0.8]

        \clip (-0.55,-0.65) rectangle (10,7); 

        
        % Draw Cartesian axes
        \draw[->,black,thick] (0,0) -- (10,0) node[above left] {$x$};
        \draw[->,black,thick] (0,0) -- (0,7) node[below right] {$y$};

        % Add numbers to the x-axis
        \foreach \x in {0,1,2,...,9}
        \draw (\x,0) -- (\x,-0.1) node[below] {\x};

        % Add numbers to the y-axis
        \foreach \y in {1,2,...,6}
        \draw (0,\y) -- (-0.1,\y) node[left] {\y};
        
        \node[draw,circle,inner sep=1.5pt,fill] at (0,0) {};
        \node[draw,circle,inner sep=1.5pt,fill] at (0,6) {};
        \node[draw,circle,inner sep=1.5pt,fill] at (1,2) {};
        \node[draw,circle,inner sep=1.5pt,fill] at (2,4) {};
        \node[draw,circle,inner sep=1.5pt,fill] at (3,6) {};
        \node[draw,circle,inner sep=1.5pt,fill] at (6,6) {};
        \node[draw,circle,inner sep=1.5pt,fill] at (5,4) {};
        \node[circle, fill, inner sep=1.8pt, label=below:$\mathbf{w}_2$] at (4,2) {};
        \node[draw,circle,inner sep=1.5pt,fill] at (3,0) {};
        \node[draw,circle,inner sep=1.5pt,fill] at (6,0) {};
        \node[draw,circle,inner sep=1.5pt,fill] at (7,2) {};
        \node[draw,circle,inner sep=1.5pt,fill] at (8,4) {};
        \node[circle, fill, inner sep=1.8pt, label=left:$\mathbf{w}$] at (5,4) {};
        \node[draw,circle,inner sep=1.5pt,fill] at (9,6) {};
        \node[draw,circle,inner sep=1.5pt,fill] at (12,6) {};
        \node[draw,circle,inner sep=1.5pt,fill] at (11,4) {};
        \node[draw,circle,inner sep=1.5pt,fill] at (10,2) {};
        \node[draw,circle,inner sep=1.5pt,fill] at (9,0) {};
        \node[draw,circle,inner sep=1.5pt,fill] at (12,0) {};
        \node[draw,circle,inner sep=1.5pt,fill] at (13,2) {};
        \node[draw,circle,inner sep=1.5pt,fill] at (14,4) {};

        
        \draw[dotted,black,ultra thick] (4,2) -- (5,4);
        \draw[dotted,black,ultra thick] (4,2) -- (7,2);
        \draw[dotted,black,ultra thick] (7,2) -- (8,4);
        \draw[dotted,black,ultra thick] (5,4) -- (8,4);

        \node[] at (6.2,3.5) {$\mathcal{F} + \mathbf{b}_1 + \mathbf{b}_2$};
        \node[circle, fill, inner sep=1.8pt, label=right:$\mathbf{t}$] at (5,3) {};
        
        
    \end{tikzpicture}
    \caption{Risoluzione del CVP usando la tecnica di arrotondamento di Babai:
    $\mathbf{w}$ è il vertice del dominio fondamentale traslato localizzato da $\mathbf{t}$, 
    quindi è soluzione per apprCVP.}
    \label{fig:lattice4}
\end{figure}

\begin{exmp} (Risoluzione del CVP usando la tecnica di arrotondamento di Babai)
    \label{exp:babai}
    \\
    Siano $\mathbf{R}$ e $\mathbf{B}$ le stesse basi definite nell'Esempio \ref{exp:basis} 
    e sia $\mathbf{t} \in \mathbb{R}^n, \mathbf{t} \notin \mathcal{L}$ con
    \[
        \mathbf{t} =
        \begin{bmatrix}
            5 & 3
        \end{bmatrix}.
    \]
    Si inizi con l'applicare l'algoritmo, dal primo passo si ottiene:
    \[
        \mathbf{R}^{-1} =
        \begin{bmatrix}
            0 & \phantom{-}0.33\\
            0.5 & -0.16
        \end{bmatrix}
        \ \text{ e } \ \mathbf{x} = \mathbf{t}\mathbf{R}^{-1} = 
        \begin{bmatrix}
            1.5 & 1.16
        \end{bmatrix}
    \]
    si applichi ora la tecnica di arrotondamento a $\mathbf{x}$:
    \[
        \lfloor\mathbf{x}\rceil = 
        \begin{bmatrix}
            2 & 1
        \end{bmatrix}
    \]
    si proceda infine con l'ottenere il risultato finale:
    \[
        \mathbf{w} = \mathbf{x}\mathbf{R} =
        \begin{bmatrix}
            5 & 4
        \end{bmatrix}
    \]  
    che, come mostrato in Figura \ref{fig:lattice4}, è il vettore più vicino
    a $\mathbf{t}$ con $\|\mathbf{t}-\mathbf{w}\|_2 = 1$. Se si dovesse valutare la qualità della base, si otterrebbe che 
    $\mathcal{H}(\mathbf{R}) = 0.94574$ e, grazie a tali proprietà ortogonali di $\mathbf{R}$,
    il dominio fondamentale derivante assume una forma geometrica tale per cui
    l'algoritmo è in grado di raggiungere facilmente la soluzione.
    \\
    Si riesegua ora l'algoritmo su $\mathbf{B}$. Calcolando $\mathcal{H}(\mathbf{B}) = 0.33231$ 
    si scopre che $\mathbf{B}$ offre una qualità molto più bassa rispetto a $\mathbf{R}$. 
    Procedendo si ottiene che:
    \[
    \mathbf{x}_2 = \mathbf{t}\mathbf{B}^{-1}=
    \begin{bmatrix}
        1.5 & 1.16
    \end{bmatrix}
    \ \text{ e quindi } \ \lfloor\mathbf{x}_2\rceil = 
    \begin{bmatrix}
        2 & 1
    \end{bmatrix}.
    \]
    Computando l'ultimo passaggio, il vettore risultante è:
    \[
        \mathbf{w}_2 = \mathbf{x}_2\mathbf{B} =
        \begin{bmatrix}
            4 & 2
        \end{bmatrix}
    \]
    il quale non è soluzione corretta all'apprCVP in quanto 
    $\|\mathbf{t}-\mathbf{w}_2\|_2 = 1.41 > \|\mathbf{t}-\mathbf{w}\|_2$. 
\end{exmp}
La principale differenza tra i due algoritmi di Babai è che il metodo del piano più vicino
risulta essere più preciso in quanto i valori frazionari vengono arrotondati in maniera
adattiva piuttosto che tutti insieme in un'unica volta. Inoltre l'utilizzo dell'aritmetica in virgola mobile, 
introdotta nella Sezione \ref{sec:LLL-variants}, consente di ottenere tempi di esecuzione 
ulteriormente più rapidi.


\subsection{Tecnica di incorporamento}
\label{sec:embedding}
Babai, oltre alla presentazione dei due algoritmi precedentemente trattati, ha dimostrato
anche quanto una base ridotta migliori l'approssimazione della soluzione ad apprCVP.
In particolare, con una base LLL-ridotta, questo porta ad un fattore di approssimazione
esponenziale per entrambi i suoi algoritmi. Nella pratica però, il metodo migliore per 
risolvere apprCVP, è la cosiddetta tecnica di
incorporamento\cite{Galbraith18}, tecnica euristica che si basa sul ridurre il CVP a un SVP.  
\\
Sia $\mathbf{B} = [\mathbf{b}_1,\dots, \mathbf{b}_n]$ la base di un reticolo $\mathcal{L}$
di dimensione $n$ e sia $\mathbf{t} \in \mathbb{R}^n, \mathbf{t} \notin \mathcal{L}$. 
La tecnica di incorporamento impone la costruzione di un reticolo di dimensione $n+1$ con
la seguente struttura:
\[
    \mathbf{M} =
    \begin{bmatrix}
        \cdots & \mathbf{b}_1 & \cdots & 0\\
        \cdots & \vdots &  \cdots &  0\\
        \cdots & \mathbf{b}_n & \cdots & 0\\
        \cdots & \mathbf{t}_1 & \cdots & 1
    \end{bmatrix}
\]
Il nuovo reticolo $\mathcal{L}(\mathbf{M})$ è strutturato in modo tale da avere lo stesso 
determinante di $\mathcal{L}(\mathbf{B})$ e quasi la stessa dimensione, ci si può quindi 
aspettare che il vettore più corto di $\mathcal{L}(\mathbf{M})$ abbia quasi la stessa 
lunghezza di quello di $\mathcal{L}(\mathbf{B})$. Si assuma che $\mathbf{w} \in \mathcal{L}$
minimizzi la distanza per $\mathbf{t}$ e sia $\mathbf{u} = \mathbf{t}-\mathbf{w}$, allora il vettore
\[
    \mathbf{v} =
    \begin{bmatrix}
        \mathbf{u} & 1
    \end{bmatrix}
\]
appartiene a $\mathcal{L}(\mathbf{M})$ e, se dovesse anche essere il suo vettore più corto, si 
potrebbe risolvere l'apprCVP di $\mathcal{L(\mathbf{B})}$ determinando l'apprSVP di $\mathcal{L}(\mathbf{M})$.
Per ottenere $\mathbf{v}$ è sufficiente ridurre $\mathbf{M}$
mediante algoritmi come LLL (o meglio BKZ) per poi ottenere $\mathbf{w}$ calcolando 
$\mathbf{t}-\mathbf{u}$.
È importante notare che il gap del reticolo di $\mathcal{L}(\mathbf{M})$ è approssimativamente il 
rapporto tra la lunghezza del vettore più corto di $\mathcal{L}(\mathbf{B})$ e la lunghezza 
di $\mathbf{u}$. Aumentare la lunghezza del vettore più corto di 
$\mathcal{L}(\mathbf{B})$ rende il gap del reticolo di $\mathcal{L}(\mathbf{M})$ più ampio, 
facilitando così la riduzione.
Quando si discute del gap del reticolo in relazione a un'istanza del CVP, è 
importante chiarire che ci si riferisce in realtà al gap del reticolo dell'istanza SVP corrispondente. 
Questa istanza SVP viene creata attraverso una tecnica di embedding che trasforma l'istanza 
CVP originale in un'istanza SVP equivalente. Pertanto, il concetto di gap del reticolo, 
originariamente definito per SVP, viene esteso indirettamente alle istanze CVP attraverso 
questa trasformazione.
Un problema nella pratica sta nella scelta di $\mathbf{t}$: teoricamente
$\mathbf{t}$ può appartenere all'insieme $\mathbb{R}$, ma questo creerebbe problemi nella
costruzione della nuova base $\mathbf{M}$ la quale non soddisferebbe più la proprietà dei 
coefficienti integrali che sta alla base della definizione di reticolo. Tale problema viene
discusso e affrontato nell'attacco di Nguyen contro GGH presentato nella Sezione \ref{sec:Nguyen}.
Nel concreto si tenta di mantenere $\mathbf{t} \in \mathbb{Z}^n$ in modo da evitare problemi
di questa natura.

\begin{exmp}(Risoluzione del CVP usando la tecnica di incorporamento)
Siano $\mathbf{R}$, $\mathbf{B}$ e $\mathbf{t}$ le stesse basi definite nell'Esempio \ref{exp:babai}.
Seguendo quanto descritto nella tecnica di incorporamento, si costruisca la matrice 
\[
    \mathbf{M} =
    \begin{bmatrix}
        \mathbf{r}_{0,0} & \mathbf{r}_{1,0} & 0\\
        \mathbf{r}_{0,1} & \mathbf{r}_{1,1} & 0\\
        \mathbf{t}_{0,0} & \mathbf{t}_{1,0} & 1
    \end{bmatrix}
    =
    \begin{bmatrix}
        1 & 2 & 0 \\
        3 & 0 & 0 \\
        5 & 3 & 1 
    \end{bmatrix}
\]
e la si riduca usando un algoritmo di riduzione, in questo caso LLL:
\begin{equation*}
    \mathbf{M}^* =
    \begin{bmatrix}
        0 & -1 & \phantom{-}1 \\
        1 & \phantom{-}1 & \phantom{-}1 \\
        2 & -1 & -1 
    \end{bmatrix}.
\end{equation*}
Infine è necessario che si estraggano i primi $n$ valori dal vettore riga più corto di 
$\mathbf{M}^*$ e sottrarli poi a $\mathbf{t}$. In questo caso il vettore più corto risulta
essere il primo, quindi $\mathbf{u} = [0 \ -1]$. Completando questo passaggio si deduce che:
\begin{equation*}
    \mathbf{w} = \mathbf{t} - \mathbf{u} =
    \begin{bmatrix*}[l]
        5 & 3
    \end{bmatrix*}
    -
    \begin{bmatrix*}[l]
        0 & -1
    \end{bmatrix*}
    =
    \begin{bmatrix*}[l]
        5 & 4
    \end{bmatrix*}
\end{equation*}
la quale è soluzione all' apprCVP con $\|\mathbf{t}-\mathbf{w}\|_2=1$.
Utilizzando la base cattiva $\mathbf{B}$, invece, si otterrebbe:
\begin{equation*}
    \mathbf{M}_2 =
    \begin{bmatrix*}[l]
        \phantom{-}5 & \phantom{-}4 & 0\\
        -6 & -6           & 0\\
        \phantom{-}5 & \phantom{-}3 & 1
    \end{bmatrix*}
    \ \text{ con } \
    \mathbf{M}_2^* =
    \begin{bmatrix*}[l]
        \phantom{-}0 & -1 & \phantom{-}1\\
        -1 & -1 & -1\\
        \phantom{-}2 & -1 & -1
    \end{bmatrix*}.
\end{equation*}
Ed effettuando l'ultimo passaggio:
\begin{equation*}
    \mathbf{w}_2 = \mathbf{t} - \mathbf{u}_2 =
    \begin{bmatrix*}[l]
        5 & 3
    \end{bmatrix*}
    -
    \begin{bmatrix*}[l]
        0 & -1
    \end{bmatrix*}
    =
    \begin{bmatrix*}[l]
        5 & 4
    \end{bmatrix*}
\end{equation*}
che è la stessa soluzione ottenuta con la base $\mathbf{R}$. 
\end{exmp}
Grazie a questo esempio si può comprendere meglio l'efficacia nella pratica di questa tecnica:
in comparazione con l'algoritmo di arrotondamento di Babai, nonostante la bassa qualità
della seconda base, si è riusciti comunque a trovare una soluzione corretta.



