\subsection{Generazione delle chiavi}
La generazione delle chiavi è un elemento cruciale in tutti i crittosistemi asimmetrici. 
In GGH, per costruire le chiavi, è indispensabile ottenere prima due basi: una 
pubblica e una privata. La sicurezza di questo crittosistema si basa sul fatto che la base pubblica 
non sia di qualità sufficientemente alta, in modo tale da impedire l'applicazione efficace 
di un algoritmo di risoluzione del CVP al testo cifrato, 
evitando così di recuperare il messaggio originale. È dunque fondamentale il modo in cui 
vengono generate la base privata e, soprattutto, la base pubblica, per garantire le 
caratteristiche necessarie a mantenere la sicurezza del crittosistema.
In questa sezione verrà quindi analizzata la struttura della funzione Generate, la quale si
occupa di quanto introdotto precedentemente. 
\\
Questa funzione prende come unico parametro in input la dimensione $n$ dalla quale dipende la
grandezza delle basi generate. In linea con quanto detto nella Sezione \ref{sec:problemi}, 
più $n$ cresce e più i problemi sui reticoli si fanno complessi, rendendo quindi più sicuro
il crittosistema. A discapito di ciò però,
man mano che la complessità aumenta, il tempo di esecuzione delle funzioni e lo spazio in
bits delle basi diventano più onerosi. Gli autori di \cite[Sezione 3.3.1]{GGH97} a tal proposito ipotizzarono
che, presi in considerazione gli algoritmi di riduzione disponibili al tempo, un $n$ tra 150 e 200 fosse
sufficiente, anche se ciò si rivelerà essere sbagliato. 
Dopo aver scelto un $n$ adeguato, si procede con il generare la base privata $\mathbf{R}$
e, successivamente, decidere la distribuzione con la quale essa verrà originata. 
Due sono le proposte avanzate:
\begin{enumerate}
    \item Generare una base $\mathbf{R}$ casuale: ogni elemento viene scelto in maniera casuale
    uniformemente nell'intervallo $[-l,\dots,l]$ per qualche valore $l$. In \cite{GGH97}
    è stato provato che la scelta di $l$ non influenza particolarmente la qualità della base
    generata, per cui è stato scelto un $l$ tra $\pm4$ al fine di semplificare alcune operazioni
    di calcolo.
    \item Generare una base $\mathbf{R}$ rettangolare: si inizia con il moltiplicare la matrice identità
    $\mathbf{I}$ per qualche numero $k$ ottenendo così $k\mathbf{I}$. 
    Si genera poi una matrice $\mathbf{R}'$ casuale (punto 1.) per poi computare
    $\mathbf{R} = \mathbf{R}' + k\mathbf{I}$.
\end{enumerate}
Come preannunciato, una volta generata la base privata $\mathbf{R}$, è necessario 
derivare la base pubblica rappresentata da un'altra base $\mathbf{B}$, tale che $\mathbf{R}$ 
e $\mathbf{B}$ generino lo stesso reticolo $\mathcal{L}$. Dato che ogni base di 
$\mathcal{L}(\mathbf{R})$ è ottenuta con $\mathbf{B} = \mathbf{R}\mathbf{U}$ per qualche matrice
unimodulare $\mathbf{U}$, allora ottenere $\mathbf{B}$ equivale ad ottenere una matrice
unimodulare casuale. Anche in questo caso, due sono i metodi proposti per generare tali matrici:
\begin{enumerate}
    \item Il primo metodo consiste nell'applicare una sequenza di operazioni elementari 
    sulle colonne della matrice identità, mantenendo però gli uni sulla diagonale principale.
    Ad ogni step viene aggiunta alla i-esima colonna una combinazione lineare intera casuale
    delle altre colonne. I coefficienti della combinazione lineare sono scelti casualmente
    in $\{-1,0,1\}$ con un bias verso zero (probabilità $\frac{5}{7}$), in modo che i numeri non
    crescano troppo velocemente. Viene suggerito dagli autori stessi di eseguire l'algoritmo
    almeno due volte.
    \item Il secondo metodo si basa sul generare delle matrici triangolari superiori 
    ($\mathbf{S}$) e inferiori ($\mathbf{L}$) con $\pm1$ sulla diagonale principale. I 
    restanti elementi della matrice che non sono zeri vengono scelti casualmente tra
    $\{-1,0,1\}$. In particolare sarà necessario moltiplicare $\mathbf{R}$ per almeno 4
    paia di $\mathbf{S}\mathbf{L}$ al fine di ottenere $\mathbf{B}$.
\end{enumerate}
E' stato provato dagli stessi autori che entrambi i metodi offrono lo stesso livello di sicurezza,
anche se il secondo, in comparazione, genera matrici con numeri più grandi andando quindi a 
complicare i calcoli successivi. \\
Dopo aver generato due $\mathbf{R}$ e $\mathbf{B}$ con le qualità necessarie, non
rimane altro che determinare $\sigma$. Questo valore è molto importante perchè esso aggiunge
una complessità maggiore per quanto riguarda l'inversione della funzione trapdoor, diventando
così un fattore di bilanciamento. Richiamando quanto definito nelle Sezioni \ref{sec:problemi}
e \ref{sec:babai}, la tecnica di arrotondamento di Babai è una proposta per la risoluzione 
dell'apprCVP, il quale, ritorna un vettore più vicino che non sempre risulta essere la soluzione più
corretta. Dato che GGH si basa su questo algoritmo per decifrare un messaggio, è possibile
definire questo crittosistema come probabilistico: in certe situazioni neanche la base
privata può essere usata per ritrovare il messaggio originale $\mathbf{M}$ e, viceversa, 
in altre situazioni, la base pubblica potrebbe essere usata per decifrare il messaggio. 
Per evitare questi casi è stato ideato il parametro $\sigma$, il 
quale, viene utilizzato per generare il vettore di errore $\mathbf{e}$ che, una volta 
aggiunto a $\mathbf{c}$, complicherà ulteriormente l'inversione. L'idea è che la
qualità di $\mathbf{B}$ sia sufficientemente bassa da non poter correggere l'errore,
ma allo stesso tempo, permettere a $\mathbf{R}$ di essere in grado di farlo. 
È cruciale che $\sigma$ non sia né troppo grande, altrimenti $\mathbf{R}$ non riuscirebbe 
a recuperare il messaggio, né troppo piccolo, per evitare che $\mathbf{B}$ possa riuscirci.
\\
In \cite[Sezione 3.2]{GGH97} vengono proposte due metriche, ciascuna basata rispettivamente
sulla norma $\text{L}_1$ e $\text{L}_\infty$, per definire un limite a
$\sigma$ in maniera che non possa causare errori di inversione usando la base privata.
La prima metrica è la più solida, poiché limita $\sigma$ a un valore massimo che garantisce 
sempre il successo dell'inversione. La seconda, invece, restringe $\sigma$ a un livello 
in cui la probabilità di errori d'inversione è molto bassa. In entrambi i casi, con 
dimensioni elevate, il valore massimo di $\sigma$ si aggira intorno a 3, risultando in un 
valore standard che bilancia sicurezza e affidabilità.
\\
Ora che tutti i parametri sono stati determinati è possibile costruire le due chiavi:
\begin{itemize}
    \item La chiave pubblica è definita semplicemente dalla coppia $(\mathbf{B}, \sigma)$
    \item La chiave privata, invece, non è definita semplicemente da $\mathbf{R}$ in quanto,
    seppure logicamente corretto, non è il metodo più efficiente. Verrà quindi utilizzata
    la coppia $(\mathbf{R}^{-1},\mathbf{T})$ con $\mathbf{T} = \mathbf{B}^{-1}\mathbf{R}$
    in modo da velocizzare la decifratura.
\end{itemize}
E' necessario precisare che, data la scelta di costruzione della chiave privata, la tecnica
di arrotondamento di Babai utilizzata risulta parametricamente diversa rispetto alla descrizione
in Sezione \ref{sec:babai}. Il funzionamento rimane però il medesimo, la decifratura avverrà
quindi come:
\[
    \mathbf{m} = \mathbf{U} \lfloor \mathbf{R}^{-1}\mathbf{c}\rceil. 
\]
E' comunque possibile utilizzare la versione originale dell'algoritmo di Babai che,
seppur meno efficiente della variante usata in GGH, ritorna comunque la stessa
soluzione. Una volta seguito il procedimento originale e aver ottenuto il vettore $\mathbf{w}$ 
più vicino a $\mathbf{c}$, sarà sufficiente esprimere 
$\mathbf{w}$ come combinazione lineare della base pubblica $\mathbf{B}$. Sfruttando il fatto
che $\mathbf{B}$ è sempre una matrice di rango massimo per definizione, sarà sufficiente calcolare
\[
    \mathbf{m} = \mathbf{B}^{-1}\mathbf{w}
    \ \text{ con } \ \mathbf{w} = \mathbf{R}\lfloor\mathbf{R}^{-1}\mathbf{c}\rceil.
\]
