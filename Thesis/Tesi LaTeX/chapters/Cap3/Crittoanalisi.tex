\section{Crittoanalisi di GGH}
\label{sec:cryptoanalysis}
In questa sezione saranno esaminate le vulnerabilità di GGH e gli attacchi derivanti da esse. 
I principali attacchi a cui GGH è soggetto includono:
\begin{itemize}
\item Computazione di una chiave privata: eseguendo una riduzione della base pubblica $\mathbf{B}$
si tenta di ottenere una chiave privata $\mathbf{B}'$ di qualità pari o simile a quella originale. 
\item Risoluzione diretta del CVP: tentare di risolvere il CVP del testo cifrato $\mathbf{c}$ 
rispetto al reticolo definito dalla base pubblica $\mathbf{B}$. 
\item Attacco di Nguyen: sfruttando la particolare struttura del vettore di errore $\mathbf{e}$ 
adottata dagli autori del crittosistema, è possibile ricondursi ad un'istanza del CVP molto più 
semplice di quella proposta da GGH.
\item Attacco basato su informazioni parziali: conoscendo sufficienti elementi del messaggio
originale è possibile costruire un'istanza del CVP ancora più semplice di quella ottenuta
tramite l'attacco di Nguyen. 
\end{itemize}

\subsection{Crittoanalisi originale}
L'attacco più ovvio e semplice tra quelli proposti è la computazione di una chiave privata per invertire la
funzione trapdoor. Uno studio dettagliato e combinato con esperimenti pratici ha portato però 
gli autori a considerarlo inefficace per una dimensione maggiore di 100.
Un miglioramento dell'attacco appena descritto consiste nell'utilizzo di uno degli algoritmi
per approssimare il CVP presentati nella Sezione \ref{sec:babai}, si rientra quindi 
nell'attacco basato su risoluzione diretta del CVP. 
Gli autori, basandosi su quanto descritto finora, hanno ipotizzato che, se l'algoritmo di 
riduzione utilizzato è LLL, il loro schema risulti sicuro per dimensioni superiori a 150
indipendentemente dal tipo di algoritmo scelto per risolvere il CVP. 
Tuttavia, poiché esistono algoritmi di riduzione migliori (Sezione \ref{sec:LLL-variants}), 
la loro conclusione è che la funzione trapdoor di GGH dovrebbe essere sicura per dimensioni 
comprese tra 250 e 300. \\
Di seguito viene presentato un esempio in dimensione 3 dell'attacco basato su 
risoluzione diretta del CVP. 
Per eseguire tale attacco sono stati utilizzati l'algoritmo LLL e la tecnica di incorporamento. 
Nonostante BKZ sia l'opzione più efficace, la bassa 
dimensionalità del problema rende i risultati ottenuti con LLL molto simili se non uguali. 
Pertanto, per semplicità, è stato scelto l'algoritmo LLL.


\begin{exmp} (Esempio di risoluzione diretta del CVP tramite incorporamento)
\label{exp:embedding}
Siano $(\mathbf{B}, \sigma)$ e $\mathbf{c}$ rispettivamente chiave pubblica e testo cifrato
utilizzati tra Alice e Bob nell'esempio \ref{exp:GGH}. Supponiamo che Eve abbia intercettato 
il testo cifrato e la chiave pubblica, e stia cercando di attaccare il crittosistema GGH
risolvendo direttamente il CVP.\\ Decide di procedere tramite tecnica di incorporamento
costruendo quindi la seguente matrice:
\begin{equation*}
    \mathbf{M} =
    \begin{bmatrix*}[l]
        \phantom{-}145 & -73 & -23 & 0\\
        -39 & \phantom{-}21 & \phantom{-}16 & 0\\
        -165 & \phantom{-}80 & \phantom{-}11 & 0 \\
        \phantom{-}4452 & -1964 & 735 & 1
    \end{bmatrix*}.
\end{equation*}
Come secondo passaggio riduce $\mathbf{M}$ tramite LLL:
\begin{equation*}
    \mathbf{M}^* =
    \begin{bmatrix*}[l]
        -2           & \phantom{-}1  & -1 & -4\\
        \phantom{-}3 & \phantom{-}3  & \phantom{-}3 & \phantom{-}1\\
        \phantom{-}0 & \phantom{-}4  & -3 & \phantom{-}3 \\
        \phantom{-}7 & -2            & -8 & -2
    \end{bmatrix*}.
\end{equation*}
Eve a questo punto, secondo quanto definito in sezione \ref{sec:embedding}, dovrebbe prelevare 
i primi $n$ valori del vettore riga di $\mathbf{M}^*$ più corto. A causa della composizione del
vettore di errore usato in GGH però la selezione del vettore da $\mathbf{M}^*$ risulta 
essere diversa. In particolare sapendo che $\sigma = 3$ Eve preleverà il vettore riga di 
forma $[\pm\sigma, \dots\pm\sigma,  1]$, che non per forza è il vettore più corto di $\mathbf{M}^*$.
In questo caso nella matrice è presente un vettore con tale forma, ovvero:
\begin{equation*}
    \begin{bmatrix*}[l]
        3 & 3 & 3 & 1
    \end{bmatrix*}
    \ \text{ con conseguente } \
    \mathbf{u} =
    \begin{bmatrix*}[l]
        3 & 3 & 3
    \end{bmatrix*}.
\end{equation*}
Come si può notare $\mathbf{u}$ è uguale al vettore di errore $\mathbf{e}$ utilizzato da Bob nell'esempio
\ref{exp:GGH}, indice del corretto andamento dell'attacco. 
Come penultimo passaggio Eve calcola il vettore $\mathbf{w}$ più vicino a $\mathbf{c}$:
\begin{equation*}
    \mathbf{w} = \mathbf{c} - \mathbf{e} =
    \begin{bmatrix*}[l]
        4452 & -1964 & 735
    \end{bmatrix*} -
    \begin{bmatrix*}[l]
        3 & 3 & 3
    \end{bmatrix*} =
    \begin{bmatrix*}[l]
        4449 & -1967 & 732
    \end{bmatrix*}
\end{equation*}
e ottiene infine il messaggio originale $\mathbf{m}$ tramite:
\begin{equation*}
    \mathbf{m} = \mathbf{w}\mathbf{B}^{-1} =
    \begin{bmatrix*}[l]
        -48 & 29 & -76
    \end{bmatrix*}.
\end{equation*}
\end{exmp}

\subsubsection{Contromisure}
La principale debolezza di GGH è intrinseca alla sua costruzione: il vettore di errore
$\mathbf{e}$ è sempre notevolmente più corto dei vettori nel reticolo. Ciò favorisce quindi
un gap di dimensione maggiore nel reticolo incorporato. Tale vulnerabilità viene sfruttata
con successo dalla tecnica di incorporamento fino ad una certa dimensione, la quale si 
colloca tra 250 e 300. Non esiste un modo semplice per risolvere questo problema senza 
sconvolgere la struttura di GGH, è dunque noto che le istanze CVP derivanti da tale schema
risultano più facili da risolvere rispetto alle istanze CVP generali. L'unica soluzione 
è anche la più veloce e ovvia: aumentare la dimensione del reticolo oltre 300, in modo da
evitare del tutto la possibilità di attacchi analoghi. 

\subsection{Attacco di Nguyen}
\label{sec:Nguyen}
Questo attacco prende il nome dal suo autore Phong Nguyen\cite{Nguyen99} il quale, nel 1999, scoprì una 
vulnerabilità nel crittosistema GGH che permise ad attacchi, come la risoluzione diretta del 
CVP, di funzionare a dimensioni ancora più elevate di quelle già precedentemente raggiunte. 
Nguyen notò che la particolare scelta di composizione del vettore di errore in GGH introdusse
un "indizio" utilizzabile per ottenere informazioni relative al messaggio $\mathbf{m}$
e addirittura semplificare il CVP del relativo testo cifrato. Richiamando quanto detto
nella sezione \Ref{sec:gghintroduction}:
\begin{equation}
    \label{eq:GGHencryption}
    \mathbf{c} = \mathbf{m}\mathbf{B} + \mathbf{e}
\end{equation}
con $\mathbf{e} = \{\pm \sigma\}$. Data la speciale forma di $\mathbf{e}$ è possibile, tramite una precisa scelta di modulo,
far scomparire il vettore di errore dall'equazione \ref{eq:GGHencryption}. Definendo
quindi un vettore $\mathbf{s} = (\sigma,\dots,\sigma) \in \mathbb{Z}^n$ e utilizzando come
modulo $2\sigma$ si ottiene che:
\[
    \mathbf{e} + \mathbf{s} \equiv 0 \ (\bmod \ 2\sigma)
\]
e di conseguenza:
\[
    \mathbf{c} + \mathbf{s} \equiv \mathbf{m}\mathbf{B} \ (\bmod \ 2\sigma).
\]
Definendo $\mathbf{cs} = \mathbf{c} + \mathbf{s}$ si arriva ad un sistema modulare di tipo
$\mathbf{y} \equiv \mathbf{B}\mathbf{x}\ (\bmod \ 2\sigma)$ che come unica incognita 
ha $\mathbf{x}$ (ovvero $\mathbf{m}$). Questa tipologia di sistemi modulari si risolve banalmente quando la matrice 
$\mathbf{B}$ è invertibile modulo $2\sigma$, permettendo di calcolare direttamente una 
soluzione unica. 
Tuttavia, se $\mathbf{B}$ non è invertibile,  il processo di risoluzione diventa significativamente 
più complesso. In queste circostanze, si presentano diverse complicazioni: il sistema può 
ammettere soluzioni multiple, manca un approccio risolutivo diretto e i metodi 
di risoluzione devono essere adattati al modulo specifico del sistema in esame. Nguyen, 
in \cite{Nguyen99}, stabilisce inizialmente che esiste una probabilità significativa
che la matrice $\mathbf{B}$ sia invertibile modulo $2\sigma$. Questa dimostrazione implica 
che in una porzione rilevante dei casi, il sistema modulare può essere risolto in modo 
diretto e semplice. Quando la matrice non è invertibile invece, Nguyen dimostra come il
kernel (e quindi il numero delle soluzioni) sia generalmente molto piccolo. In particolare
viene rilevato che solo una parte molto piccola delle matrici modulo 6 (che è il doppio del 
parametro $\sigma = 3$ suggerito) ha un kernel con più di 12 elementi. \\
Nguyen conclude quindi che, per la scelta suggerita di parametri $(n, \sigma)$ e per qualsiasi 
testo cifrato $\mathbf{c}$, il sistema lineare ha, molto probabilmente, pochissime soluzioni. \\
Si denoti con $\mathbf{m}_{2\sigma}$ il messaggio in chiaro modulo $2\sigma$ ottenuto 
risolvendo il precedente sistema modulare. Si supponga ora che $\mathbf{B}$ sia invertibile
modulo $2\sigma$, allora il sistema ha una sola soluzione 
$\mathbf{m}_{2\sigma}$ = $(\mathbf{c} + \mathbf{s})\mathbf{B}^{-1}$. Sottraendo $\mathbf{m}_{2\sigma}\mathbf{B}$ 
in entrambe le parti dell'equazione \ref{eq:GGHencryption} si consegue:
\[
    \mathbf{c} - \mathbf{m}_{2\sigma}\mathbf{B} = \mathbf{m}\mathbf{B} + \mathbf{e} - \mathbf{m}_{2\sigma}\mathbf{B}
\]
e, raccogliendo $\mathbf{B}$ nella seconda parte dell'equazione, si ottiene quindi:
\begin{equation}
    \label{eq:Nguyen1}
    \mathbf{c} - \mathbf{m}_{2\sigma}\mathbf{B} = (\mathbf{m} - \mathbf{m}_{2\sigma})\mathbf{B} + \mathbf{e}.
\end{equation}
Un'importante osservazione è che, essendo $\mathbf{m}_{2\sigma}$ congruente a $\mathbf{m}$ 
modulo $2\sigma$, la differenza $(\mathbf{m} - \mathbf{m}_{2\sigma})$ risulta per definizione 
divisibile per $2\sigma$. Questa proprietà consente di rappresentare tale differenza 
come il prodotto tra $2\sigma$ e un nuovo intero $\mathbf{m}'$, esprimendola nella 
forma $\mathbf{m} - \mathbf{m}_{2\sigma} = 2\sigma\mathbf{m}'$, dove $\mathbf{m}'$ 
costituisce il quoziente intero derivante da questa divisione. E' possibile quindi riscrivere
\ref{eq:Nguyen1} come:
\[
    \mathbf{c} - \mathbf{m}_{2\sigma}\mathbf{B} = (2\sigma\mathbf{m}')\mathbf{B} + \mathbf{e}
\]
e, dividendo per $2\sigma$ in entrambe le parti, si ottiene infine:
\begin{equation}
    \label{eq:Nguyen2}
    \frac{\mathbf{c} - \mathbf{m}_{2\sigma}\mathbf{B}}{2\sigma} = \mathbf{m}'\mathbf{B} + \frac{\mathbf{e}}{2\sigma}. 
\end{equation}
L'equazione \Ref{eq:Nguyen2} nella sua forma finale mostra una chiara divisione in due 
parti: la prima rappresenta un punto razionale con tutti gli elementi noti, 
permettendone così un calcolo diretto; la seconda mantiene la struttura della formula 
\ref{eq:GGHencryption}, differenziandosi unicamente per la presenza del messaggio $\mathbf{m}'$.
Ne consegue quindi che tale equazione può essere letta come un CVP per il quale il vettore di 
errore $\frac{\mathbf{e}}{2\sigma} \in \{\pm\frac{1}{2}\}^n$ risulta essere molto più piccolo
di quello proposto da GGH. Data la relazione tra i due errori, conseguente dal procedimento appena
illustrato, se si è in grado di risolvere il ben più semplice CVP posto dall'equazione 
\ref{eq:Nguyen2} allora è possibile risolvere anche il CVP originale. In altre parole 
Nguyen, grazie alla sua intuzione, è riuscito a ridurre l'istanza del CVP di GGH in una più
semplice. \\
L'attacco di Nguyen può essere meglio descritto come una semplificazione del CVP di GGH, 
semplificazione che può essere sfruttata da algoritmi di risoluzione del CVP come la 
tecnica di incorporamento. Infatti, una volta risolto il CVP semplificato, si otterrà 
$\mathbf{m}'$ con il quale sarà possibile calcolare il messaggio originale attraverso: 
\[
    \mathbf{m} = \mathbf{m}_{2\sigma} + 2\sigma\mathbf{m}'.
\] 
Successivamente alla pubblicazione di GGH nel 1997, vennero
pubblicate delle "internet challenges": delle sfide lanciate dagli autori su internet
al fine di testare quanto il loro schema fosse sicuro. Le sfide erano composte da 5 istanze di GGH
delle quali si era a conoscenza solo del testo cifrato e della chiave pubblica. Ogni sfida 
era più difficile della precedente, spaziando più precisamente nelle seguenti dimensioni: 
200, 250, 300, 350 e 400. Per validare il suo attacco, Nguyen, riuscì a recuperare il messaggio 
originale in tutte le sfide ad eccezione dell'ultima in dimensione 400, dove ottenne solo informazioni 
parziali. La sua strategia si articolò in due fasi: per dimensioni fino a 300, impiegò la 
tecnica di incorporamento con BKZ a blocchi di 20, mentre per le dimensioni superiori combinò lo stesso 
algoritmo di risoluzione per il CVP con una versione potata di BKZ a blocchi di 60. Per migliorare la 
stabilità, entrambe le varianti di BKZ furono implementate utilizzando l'aritmetica a 
virgola mobile. Un problema precedentemente introdotto nella sezione \ref{sec:embedding} 
è l'uso di valori non interi nella costruzione della matrice secondo la tecnica di incorporamento. 
Infatti, secondo quanto ottenuto nell'equazione \ref{eq:Nguyen2}, 
$\mathbf{e} \in \{\pm\frac{1}{2}\}^n$ conseguendo quindi che la parte sinistra dell'equazione
non sia più un vettore di soli elementi interi. Per risolvere tale problema Nguyen propose
due soluzioni:
\begin{enumerate}
    \item Moltiplicare per 2 l'equazione \ref{eq:Nguyen2} ottenendo così $\mathbf{e} \in \{\pm 1\}^n$.
    Ciò però consegue che anche la base pubblica $\mathbf{B}$ sarà moltiplicata per 2 causando un
    aumento di complessità dei calcoli con reticoli di grandi dimensioni. 
    \item Aggiungere un vettore costante  $\mathbf{s} = (\sigma,\dots,\sigma)$ e 
    successivamente scalare l'intero sistema per un fattore $2\sigma$.
    Questa manipolazione matematica semplifica i calcoli, poiché il vettore di errore risultante 
    contiene solo valori 0 o 1. Tuttavia, è importante notare che questa trasformazione comporta un 
    leggero aumento della lunghezza prevista del vettore di errore. Per un esempio più dettagliato si
    veda \cite[
        Sezione 5]{Nguyen99}
\end{enumerate} 
\begin{exmp}(Esempio dell'attacco di Nguyen a GGH tramite incorporamento) 
Siano $(\mathbf{B}, \sigma)$ e $\mathbf{c}$ rispettivamente chiave pubblica e testo cifrato
utilizzati tra Alice e Bob nell'esempio \ref{exp:GGH}. Si supponga che Eve abbia intercettato 
il testo cifrato e la chiave pubblica. Eve, venuta a conoscenza della scoperta di Nguyen, 
tenta così di decifrare il messaggio cifrato sfruttando tale informazione.
Eve innanzitutto verifica
se la base pubblica $\mathbf{B}$ sia invertibile modulo $2\sigma$. Per fare ciò calcola 
$\det(\mathbf{B}) = 781$ e controlla se esso sia coprimo con $2\sigma=6$. Scopre così che 
$\mathbf{B}$ è effettivamente invertibile, di conseguenza, il sistema modulare ha un'unica 
soluzione, che può essere determinata direttamente:
\[
    (\mathbf{c}+\mathbf{s})\mathbf{B}^{-1} \equiv \mathbf{m} \ (\bmod \ 2\sigma)
\]
\[
    \mathbf{m}_{2\sigma} = (\mathbf{c}+\mathbf{s})\mathbf{B}^{-1} \ (\bmod \ 2\sigma)
\]
\begin{equation*}
    \mathbf{m}_{2\sigma} =
    \Biggl(
    \begin{bmatrix*}[l]
        4452 & -1964 & 735
    \end{bmatrix*}
    +
    \begin{bmatrix*}[l]
        3 & 3 & 3
    \end{bmatrix*}
    \Biggl)
    \begin{bmatrix*}[l]
        1 & 1 & 5\\
        3 & 2 & 5\\
        3 & 1 & 0
    \end{bmatrix*}
     \ (\bmod \ 2\sigma)
    =
    \begin{bmatrix*}[l]
        0 & 5 & 2
    \end{bmatrix*}.
\end{equation*}
Eve, ottenuto $\mathbf{m}_{2\sigma}$, procede con il calcolare il CVP semplificato tramite
l'equazione \ref{eq:Nguyen2}. Dato che vuole utilizzare la tecnica di incorporamento per
risolverlo nel passaggio successivo, moltiplica per 2 la frazione in modo da liberarsi di 
valori con la virgola. Tale moltiplicazione andrà poi riflessa su $\mathbf{B}$ anche nei 
passaggi successivi all'estrazione del vettore $\mathbf{e}$.
\[
    \mathbf{c}^* = 2 \Bigl(\frac{\mathbf{c} - \mathbf{m}_{2\sigma}\mathbf{B}}{2\sigma}\Bigl)
    = 
    \begin{bmatrix*}[l]
        1659 & -743 & 211
    \end{bmatrix*}.
\]
Ora che Eve ha ottenuto un'istanza semplificata del CVP originale, procede con gli stessi
passaggi presentati nell'esempio \ref{exp:embedding}, ma utilizzando il nuovo $\mathbf{c}^*$
invece che $\mathbf{c}$.

\begin{equation*}
    \mathbf{M} =
    \begin{bmatrix*}[l]
        \phantom{-}145 & -73 & -23 & 0\\
        -39 & \phantom{-}21 & \phantom{-}16 & 0\\
        -165 & \phantom{-}80 & \phantom{-}11 & 0 \\
        \phantom{-}1659 & -743 & 211 & 1
    \end{bmatrix*}.
\end{equation*}
Nell'esempio \ref{exp:embedding} Eve usò LLL come algoritmo di riduzione. In questo attacco,
per una maggiore sicurezza, decide di usare BKZ. Ottiene quindi la matrice:
\begin{equation*}
    \mathbf{M}^* =
    \begin{bmatrix*}[l]
        \phantom{-}1 & \phantom{-}1 & \phantom{-}1 & \phantom{-}1\\
                  -1 & \phantom{-}6 &           -3 & -2\\
        \phantom{-}3 &           -1 & \phantom{-}6 & -6 \\
        \phantom{-}9 & \phantom{-}0 &           -6 & -4
    \end{bmatrix*}
    \ \text{ con } \
    \mathbf{e} =
    \begin{bmatrix*}[l]
        1 & 1 & 1
    \end{bmatrix*}.
\end{equation*}

Dopo aver costruito il vettore $\mathbf{u}$, Eve è ora in grado di calcolare $\mathbf{m}'$,
ricordandosì però che ora è necessario raddoppiare $\mathbf{B}$. 
\begin{equation*}
    \mathbf{m}' =  (\mathbf{c}^* - \mathbf{u}) (2\mathbf{B})^{-1}=
    \begin{bmatrix*}[l]
        -8 & 4 & -13
    \end{bmatrix*}.
\end{equation*}
Eve, come ultimo passaggio, decifra il messaggio originale tramite:
\[
    \mathbf{m} = \mathbf{m}_{2\sigma} + 2\sigma\mathbf{m}' =
    \begin{bmatrix*}[l]
        0 & 5 & 2
    \end{bmatrix*} + 
    \Biggl(
        6
        \begin{bmatrix*}[l]
            -8 & 4 & -13
        \end{bmatrix*}
    \Biggl)
    =
    \begin{bmatrix*}[l]
        -48 & 29 & -76
    \end{bmatrix*}.
\]
\end{exmp}
\subsubsection{Contromisure}
Nguyen stesso propose delle modifiche allo schema originale in \cite[Sezione 7]{Nguyen99} 
per contrastare la vulnerabilità da lui scoperta e riparare lo schema GGH.
La vulnerabilità principale del sistema è riconducibile alla particolare struttura del
vettore di errore $\mathbf{e}$, come definito dagli autori in \cite{GGH97}. Per mitigare 
questo problema, un approccio intuitivo consiste nel modificare l'intervallo dei possibili 
valori che le componenti del vettore possono assumere. Specificamente, Nguyen propose di 
adottare un intervallo più ampio $[-\sigma, \dots, +\sigma]$, in sostituzione del più 
ristretto insieme ${\pm\sigma}$ originariamente utilizzato. Il nuovo vettore di errore risolve
con successo la vulnerabilità sfruttata da Nguyen, ma rende il vettore stesso più corto, 
aumentando così il gap del reticolo incorporato e rendendo lo schema più vulnerabile ad 
attacchi basati su tecnica di incorporamento. 

\subsection{Attacco basato su informazioni parziali}
Per quanto la vulnerabilità scoperta da Nguyen renda molto più facile l'attacco a GGH, essa
non si rivelò sufficiente per dimensioni superiori a 400. A tal proposito nel 2010, Moon Sung Lee 
e Sang Geun Hahn\cite{Nguyen400}, proposero un attacco in grado di rompere la barriera 
dimensionale a cui i precedenti attacchi si fermarono. Mentre sia questo attacco che quello 
di Nguyen mirano a semplificare il CVP, essi differiscono nel metodo: 
Nguyen riduce la lunghezza del vettore di errore $\mathbf{e}$, mentre questo nuovo approccio 
aumenta la lunghezza del vettore più corto nel reticolo definito dalla base pubblica.
Per fare ciò però è necessario che un numero $k$ di valori del messaggio originale siano noti,
tale conoscenza risulta essere possibile solo in alcuni casi. Il metodo su cui si basa
l'attacco è il seguente.\\
Sia $\mathbf{m}^1$ il vettore composto dai primi $k$ degli $n$ valori di $\mathbf{m}$ (noti) e
sia $\mathbf{m}^2$ il vettore composto dai restanti valori di $\mathbf{m}$. Similmente, sia 
$\mathbf{B}^1$ la matrice composta dalle prime $\mathbf{k}$ righe della base
pubblica $\mathbf{B}$ e sia $\mathbf{B}^2$ la matrice composta dalle righe rimanenti di
$\mathbf{B}$. Allora si ha che:
\begin{equation*}
    \mathbf{c} = \mathbf{m}\mathbf{B} + \mathbf{e} =
    (\mathbf{m}^1 \ \mathbf{m}^2)\biggl(\genfrac{}{}{0pt}{}{\mathbf{B}^1}{\mathbf{B}^2}\biggl) + \ \mathbf{e}
    = \mathbf{m}^1\mathbf{B}^1 + \mathbf{m}^2\mathbf{B}^2 + \mathbf{e}
\end{equation*}
da cui si deriva:
\begin{equation}
    \label{eq:nguyen400}
    \mathbf{c} - \mathbf{m}^1\mathbf{B}^1 = \mathbf{m}^2\mathbf{B}^2 + \mathbf{e}.
\end{equation}
Data l'assunzione iniziale, la prima componente dell'equazione \ref{eq:nguyen400} è conosciuta. 
La seconda componente, analogamente all'equazione \ref{eq:Nguyen2} discussa in precedenza, 
può essere ricondotta a una versione semplificata del CVP originale. 
Tuttavia, in questo caso, il problema è definito su un reticolo $\mathcal{L}(\mathbf{B}_2)$ 
che è un sottoinsieme del reticolo originale $\mathcal{L}(\mathbf{B})$, ma distinto da esso. 
La risoluzione del nuovo CVP implica la risoluzione dell'istanza 
originale del problema. Tale affermazione sussiste in quanto il rango della matrice su cui
viene risolta risulta essere $n-k$ e quindi molto più piccola dell'originale.  
Per validare il loro metodo, gli autori di \cite{Nguyen400} applicarono l'attacco alla
sfida rimanente in dimensione 400, sfruttando anche la vulnerabilità scoperta da Nguyen. 
Il corretto funzionamento richiedeva la determinazione di $k$ valori del messaggio originale. 
Sapendo che il messaggio era composto da 400 numeri interi 
$\mathbf{m} = (\mathbf{m}_1, \mathbf{m}_2,\dots, \mathbf{m}_{400})$, 
con $\mathbf{m}_i \in [-128, 127]$, e che $\mathbf{m}_1 \bmod 6 = 5$ 
grazie alle informazioni parziali rilevate da Nguyen, si dedusse l'esistenza di sole 43 possibilità 
per $\mathbf{m}^1 = (\mathbf{m}_1)$, ovvero $(-127), (-121), \dots, (125)$. 
Questa deduzione permise di restringere significativamente lo spazio di ricerca per 
l'attacco, rendendo il metodo più efficace e praticabile.
In conclusione quindi, gli autori di \cite{Nguyen400}, riuscirono a rompere la challenge
in dimensione 400 avendo a dispozione un solo valore del messaggio originale.

\subsubsection{Contromisure}
Dato l'utilizzo della vulnerabilità scoperta da Nguyen al fine di indovinare valori del
messaggio originale è logico pensare che la contromisura proposta da Nguyen sia sufficiente
al fine di proteggere l'algoritmo da questo attacco. Questa affermazione risulta vera, ma solo
se effettivamente non c'è una perdita di informazione relativa al messaggio originale. 
In \cite{Nguyen400} viene discussa la possibilità di un attacco alle challenge 350 e 400
senza utilzzare la tecnica di Nguyen. 
Gli autori scoprirono che per decifrare con successo il messaggio originale, era necessario 
fare supposizioni su 9 e 17 valori $(k)$ per le rispettive sfide. Considerando che lo schema 
GGH originale definisce i valori del messaggio nell'intervallo $[-128, +127]$, indovinare un 
singolo elemento richiederebbe $2^8$ tentativi, mentre per k elementi sarebbero necessari 
$2^{(8k)}$ tentativi. Risulta evidente che un approccio di questo tipo sarebbe impraticabile 
sia in termini di tempo che di risorse computazionali.